<!doctype html>
<html lang="zh-TW" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è©å½™é…å°éŠæˆ²</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
    }
    * {
      font-family: 'Nunito', sans-serif;
    }
    
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
      50% { box-shadow: 0 0 20px 10px rgba(99, 102, 241, 0.2); }
    }
    
    @keyframes celebrate {
      0% { transform: scale(1); }
      25% { transform: scale(1.1) rotate(-3deg); }
      50% { transform: scale(1.15) rotate(3deg); }
      75% { transform: scale(1.1) rotate(-3deg); }
      100% { transform: scale(1); }
    }
    
    @keyframes confetti-fall {
      0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-5px); }
      40%, 80% { transform: translateX(5px); }
    }
    
    @keyframes float-in {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes hint-pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
      50% { transform: scale(1.05); box-shadow: 0 0 20px 10px rgba(251, 191, 36, 0.3); }
    }
    
    .card-selected {
      animation: pulse-glow 1.5s infinite;
    }
    
    .card-matched {
      animation: celebrate 0.6s ease-out;
    }
    
    .card-wrong {
      animation: shake 0.5s ease-out;
    }
    
    .card-hint {
      animation: hint-pulse 1s infinite;
    }
    
    .float-in {
      animation: float-in 0.5s ease-out forwards;
    }
    
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      animation: confetti-fall 3s linear forwards;
      pointer-events: none;
      z-index: 1000;
    }
    
    .connection-line {
      pointer-events: none;
      position: absolute;
      z-index: 5;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div id="app" class="h-full w-full bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 overflow-auto">
   <div class="min-h-full p-4 md:p-8"><!-- Header -->
    <header class="text-center mb-6 md:mb-8">
     <h1 id="game-title" class="text-3xl md:text-4xl font-extrabold text-white mb-2 drop-shadow-lg">â›°ï¸ ç™»å±±çŸ¥è­˜é…å°æŒ‘æˆ°</h1>
     <p class="text-purple-200 text-sm md:text-base">æŒ‰ä½ä¸¦æ‹–æ›³å·¦é‚Šçš„è©å½™åˆ°å³é‚Šçš„å®šç¾©ä¾†é…å°</p>
    </header><!-- Score & Progress -->
    <div class="flex justify-center gap-4 md:gap-8 mb-6">
     <div class="bg-white/10 backdrop-blur-sm rounded-2xl px-4 py-2 md:px-6 md:py-3"><span class="text-purple-200 text-sm">å¾—åˆ†</span>
      <p id="score" class="text-2xl md:text-3xl font-bold text-yellow-400">0</p>
     </div>
     <div class="bg-white/10 backdrop-blur-sm rounded-2xl px-4 py-2 md:px-6 md:py-3"><span class="text-purple-200 text-sm">é…å°é€²åº¦</span>
      <p id="progress" class="text-2xl md:text-3xl font-bold text-green-400">0/6</p>
     </div>
     <div class="bg-white/10 backdrop-blur-sm rounded-2xl px-4 py-2 md:px-6 md:py-3"><span class="text-purple-200 text-sm">é€£çºŒæ­£ç¢º</span>
      <p id="streak" class="text-2xl md:text-3xl font-bold text-pink-400">0</p>
     </div>
    </div><!-- Hint Message -->
    <div id="hint-message" class="hidden text-center mb-4">
     <div class="inline-block bg-yellow-400/20 backdrop-blur-sm rounded-xl px-4 py-2 border-2 border-yellow-400/50"><span class="text-yellow-300 font-semibold" id="hint-text"></span>
     </div>
    </div><!-- Game Board -->
    <div class="relative max-w-4xl mx-auto" id="game-container">
     <svg id="connection-svg" class="connection-line w-full h-full" style="position: absolute; top: 0; left: 0;"></svg>
     <div class="grid grid-cols-2 gap-4 md:gap-8"><!-- Terms Column -->
      <div id="terms-column" class="space-y-3 md:space-y-4">
      </div><!-- Definitions Column -->
      <div id="definitions-column" class="space-y-3 md:space-y-4">
      </div>
     </div>
    </div><!-- Controls -->
    <div class="flex justify-center gap-4 mt-8"><button id="hint-btn" class="bg-gradient-to-r from-yellow-400 to-orange-500 hover:from-yellow-500 hover:to-orange-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200 flex items-center gap-2"> <span>ğŸ’¡</span> <span id="hint-btn-text">æç¤º</span> <span id="hints-remaining" class="bg-white/30 rounded-full px-2 py-0.5 text-sm">3</span> </button> <button id="restart-btn" class="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200 flex items-center gap-2"> <span>ğŸ”„</span> <span id="restart-btn-text">é‡æ–°é–‹å§‹</span> </button>
    </div><!-- Completion Modal -->
    <div id="completion-modal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4">
     <div class="bg-gradient-to-br from-purple-600 to-pink-600 rounded-3xl p-8 text-center max-w-md w-full shadow-2xl">
      <div class="text-6xl mb-4">
       ğŸ‰
      </div>
      <h2 class="text-3xl font-extrabold text-white mb-2">å¤ªæ£’äº†ï¼</h2>
      <p class="text-purple-200 mb-4">ä½ æˆåŠŸé…å°äº†æ‰€æœ‰è©å½™ï¼</p>
      <div class="bg-white/20 rounded-2xl p-4 mb-6">
       <p class="text-white">æœ€çµ‚å¾—åˆ†</p>
       <p id="final-score" class="text-5xl font-extrabold text-yellow-400">0</p>
      </div><button id="play-again-btn" class="bg-white text-purple-600 font-bold py-3 px-8 rounded-xl hover:bg-purple-100 transition-all duration-200 transform hover:scale-105"> å†ç©ä¸€æ¬¡ ğŸš€ </button>
     </div>
    </div>
   </div>
  </div>
  <script>
    // Game Data - 50 é¡Œç™»å±±çŸ¥è­˜
    const allVocabularyData = [
      { id: 1, term: "é«˜å±±ç—‡", definition: "åœ¨é«˜æµ·æ‹”åœ°å€å› æ°§æ°£ä¸è¶³è€Œç”¢ç”Ÿçš„èº«é«”ä¸é©ç—‡ç‹€", hint: "çˆ¬å¾—å¤ªé«˜å¤ªå¿«æ™‚å®¹æ˜“ç™¼ç”Ÿ" },
      { id: 2, term: "ä¸‰è§’é»", definition: "æ¨™ç¤ºå±±é ‚æˆ–æ¸¬é‡é»ä½ç½®çš„çŸ³è£½æ¸¬é‡æ¨™è¨˜", hint: "ç™»é ‚æ™‚å¸¸æœƒçœ‹åˆ°çš„çŸ³ç¢‘" },
      { id: 3, term: "ç­‰é«˜ç·š", definition: "åœ°åœ–ä¸Šé€£æ¥ç›¸åŒæµ·æ‹”é«˜åº¦å„é»çš„æ›²ç·š", hint: "è¶Šå¯†é›†ä»£è¡¨å¡åº¦è¶Šé™¡" },
      { id: 4, term: "è¡Œå‹•ç³§", definition: "ç™»å±±é€”ä¸­è£œå……é«”åŠ›çš„é«˜ç†±é‡é£Ÿç‰©", hint: "å·§å…‹åŠ›å’Œå …æœå°±æ˜¯å¸¸è¦‹çš„é€™å€‹" },
      { id: 5, term: "æ”»é ‚", definition: "æˆåŠŸç™»ä¸Šå±±å³°çš„æœ€é«˜é»", hint: "ç™»å±±è€…çš„æœ€çµ‚ç›®æ¨™" },
      { id: 6, term: "ç¨œç·š", definition: "å±±è„Šæˆ–å±±å³°é ‚éƒ¨é€£æ¥çš„ç·šæ¢æˆ–è·¯å¾‘", hint: "èµ°åœ¨å±±çš„èƒŒè„Šä¸Š" },
      { id: 7, term: "åŸºåœ°ç‡Ÿ", definition: "ç™»å±±æ´»å‹•ä¸­ä½œç‚ºä¼‘æ¯å’Œè£œçµ¦çš„ç‡Ÿåœ°", hint: "æ”€ç™»é«˜å³°å‰çš„ä¸­ç¹¼ç«™" },
      { id: 8, term: "å†°çˆª", definition: "ç¶åœ¨ç™»å±±é‹åº•ç”¨æ–¼é›ªåœ°è¡Œèµ°çš„é‡‘å±¬é½’ç‹€è£å‚™", hint: "é›ªåœ°ä¸Šçš„é˜²æ»‘è£å‚™" },
      { id: 9, term: "ç¢ºä¿", definition: "ä½¿ç”¨ç¹©ç´¢å’Œè£å‚™ä¿è­·æ”€ç™»è€…å®‰å…¨çš„æŠ€è¡“", hint: "æ”€å²©æ™‚çš„å®‰å…¨æªæ–½" },
      { id: 10, term: "å‚é™", definition: "ä½¿ç”¨ç¹©ç´¢å¾é«˜è™•ä¸‹é™çš„æŠ€è¡“", hint: "å¾€ä¸‹èµ°æ¯”å¾€ä¸Šçˆ¬æ›´éœ€è¦é€™å€‹æŠ€è¡“" },
      { id: 11, term: "ç¸±èµ°", definition: "æ²¿è‘—å±±è„ˆç¨œç·šé€£çºŒæ”€ç™»å¤šåº§å±±å³°", hint: "ä¸€æ¬¡çˆ¬å¥½å¹¾åº§å±±" },
      { id: 12, term: "èƒŒå·¥", definition: "å”åŠ©ç™»å±±è€…èƒŒè² è£å‚™å’Œç‰©è³‡çš„å°ˆæ¥­äººå“¡", hint: "å¹«å¿™æ‰›é‡ç‰©çš„å°ˆæ¥­äººå“¡" },
      { id: 13, term: "å±±å±‹", definition: "è¨­ç½®åœ¨å±±å€ä¾›ç™»å±±è€…ä¼‘æ¯éå¤œçš„ç°¡æ˜“å»ºç¯‰", hint: "å±±ä¸Šçš„ä½å®¿é»" },
      { id: 14, term: "é›ªç›²", definition: "å› é›ªåœ°å¼·å…‰åå°„é€ æˆçš„çœ¼ç›å‚·å®³", hint: "é›ªåœ°å¤ªäº®é€ æˆçš„çœ¼ç–¾" },
      { id: 15, term: "å¤±æº«", definition: "é«”æº«ä¸‹é™è‡³å±éšªç¨‹åº¦çš„ç‹€æ³", hint: "å¤©æ°£å¤ªå†·å°è‡´çš„å±éšªç‹€æ³" },
      { id: 16, term: "æ¶ç¹©", definition: "åœ¨å±éšªè·¯æ®µæ¶è¨­ç¹©ç´¢ä»¥åˆ©é€šè¡Œ", hint: "å¹«å¤§å®¶æ‹‰ä¸Šå›ºå®šçš„ç¹©å­" },
      { id: 17, term: "ç™»å±±æ–", definition: "å”åŠ©è¡Œèµ°å’Œç¶­æŒå¹³è¡¡çš„æ‰‹æŒè£å‚™", hint: "åƒæ‹æ–ä¸€æ¨£çš„ç™»å±±å·¥å…·" },
      { id: 18, term: "æ°´è¢‹", definition: "æ–¹ä¾¿åœ¨è¡Œé€²ä¸­è£œå……æ°´åˆ†çš„è»Ÿå¼å„²æ°´è£å‚™", hint: "ä¸ç”¨åœä¸‹ä¾†å°±èƒ½å–æ°´çš„è£å‚™" },
      { id: 19, term: "é ­ç‡ˆ", definition: "æˆ´åœ¨é ­ä¸Šçš„ç…§æ˜å·¥å…·", hint: "é»‘æš—ä¸­è§£æ”¾é›™æ‰‹çš„ç‡ˆå…·" },
      { id: 20, term: "é³¥å˜´", definition: "å±±å³°å°–éŠ³çªå‡ºçš„å²©çŸ³åœ°å½¢", hint: "å½¢ç‹€åƒé³¥å˜´çš„å²©çŸ³" },
      { id: 21, term: "ç®­ç«¹", definition: "é«˜å±±åœ°å€å¸¸è¦‹çš„ç«¹é¡æ¤ç‰©", hint: "å°ç£å±±å€å¸¸è¦‹çš„æ¤ç‰©" },
      { id: 22, term: "æ¨¹é™", definition: "æ¨¹æœ¨èƒ½å¤ ç”Ÿé•·çš„æœ€é«˜æµ·æ‹”ç•Œç·š", hint: "å†é«˜å°±æ²’æœ‰æ¨¹æœ¨äº†" },
      { id: 23, term: "é¢¨åˆ‡", definition: "å¼·é¢¨å¹éç¨œç·šæˆ–å±±å³°çš„ç¾è±¡", hint: "ç¨œç·šä¸Šçš„å¼·é¢¨" },
      { id: 24, term: "å¥½å¤©", definition: "é©åˆç™»å±±çš„æ™´æœ—å¤©æ°£", hint: "ç™»å±±æœ€å–œæ­¡çš„å¤©æ°£" },
      { id: 25, term: "åˆå¾Œé›·é™£é›¨", definition: "å±±å€ä¸‹åˆå¸¸å‡ºç¾çš„é›·é›¨å¤©æ°£", hint: "å¤å¤©ä¸‹åˆå±±ä¸Šçš„å¸¸è¦‹ç¾è±¡" },
      { id: 26, term: "é›²æµ·", definition: "å¾é«˜è™•ä¿¯ç°é›²å±¤å½¢æˆçš„æ™¯è§€", hint: "åƒæµ·æ´‹ä¸€æ¨£çš„é›²å±¤" },
      { id: 27, term: "æ—¥å‡º", definition: "å¤ªé™½å‡èµ·çš„æ™‚åˆ»å’Œæ™¯è±¡", hint: "æ—©èµ·ç™»å±±çš„çå‹µ" },
      { id: 28, term: "çµç¹©", definition: "ç¶ç¹©ç´¢çš„å„ç¨®æŠ€è¡“å’Œæ–¹æ³•", hint: "ç¹©å­çš„æ‰“çµæŠ€å·§" },
      { id: 29, term: "æ‰å¸¶", definition: "æ‰å¹³ç‹€çš„æ”€ç™»ç”¨ç¹©å¸¶", hint: "æ‰çš„ä¸æ˜¯åœ“çš„ç¹©å­" },
      { id: 30, term: "å¿«æ‰£", definition: "ç”¨æ–¼é€£æ¥ç¹©ç´¢å’Œå›ºå®šé»çš„é‡‘å±¬æ‰£ç’°", hint: "å¿«é€Ÿé€£æ¥ç”¨çš„é‡‘å±¬æ‰£" },
      { id: 31, term: "å²©é‡˜", definition: "æ‰“å…¥å²©å£ä½œç‚ºå›ºå®šé»çš„é‡‘å±¬é‡˜", hint: "é‡˜é€²çŸ³é ­çš„å›ºå®šè£ç½®" },
      { id: 32, term: "æº¯æºª", definition: "æ²¿è‘—æºªæµå‘ä¸Šæ¸¸å‰é€²çš„æ´»å‹•", hint: "åœ¨æºªè°·ä¸­é€†æµè€Œä¸Š" },
      { id: 33, term: "å´©å£", definition: "é™¡å³­æ˜“å´©å¡Œçš„å±±å£åœ°å½¢", hint: "å¾ˆå®¹æ˜“å´©è½çš„å±éšªåœ°å½¢" },
      { id: 34, term: "ç¢çŸ³å¡", definition: "ä½ˆæ»¿ç¢çŸ³çš„æ–œå¡åœ°å½¢", hint: "å®¹æ˜“æ»‘å€’çš„çŸ³é ­æ–œå¡" },
      { id: 35, term: "ç¨æ”€", definition: "ä¸€å€‹äººå–®ç¨ç™»å±±", hint: "æ²’æœ‰å¤¥ä¼´çš„ç™»å±±æ–¹å¼" },
      { id: 36, term: "è¼•é‡åŒ–", definition: "æ¸›è¼•èƒŒåŒ…é‡é‡çš„ç™»å±±å“²å­¸", hint: "è£å‚™è¶Šè¼•è¶Šå¥½çš„æ¦‚å¿µ" },
      { id: 37, term: "ç•™å®ˆ", definition: "è¨˜éŒ„ç™»å±±è€…è¡Œç¨‹ä¸¦è² è²¬è¯ç¹«çš„äººå“¡", hint: "åœ¨å±±ä¸‹ç­‰å¾…çš„è¯çµ¡äºº" },
      { id: 38, term: "å…¥å±±è­‰", definition: "é€²å…¥ç®¡åˆ¶å±±å€æ‰€éœ€çš„è¨±å¯æ–‡ä»¶", hint: "é€²å±±å‰è¦ç”³è«‹çš„è­‰æ˜" },
      { id: 39, term: "å±±é›£", definition: "ç™»å±±éç¨‹ä¸­ç™¼ç”Ÿçš„æ„å¤–äº‹æ•…", hint: "å±±ä¸Šç™¼ç”Ÿçš„ç·Šæ€¥ç‹€æ³" },
      { id: 40, term: "æ’¤é€€", definition: "å› å¤©å€™æˆ–é«”åŠ›ç­‰å› ç´ æ”¾æ£„æ”»é ‚ä¸‹å±±", hint: "å®‰å…¨ç¬¬ä¸€ï¼Œæ”¾æ£„ç™»é ‚" },
      { id: 41, term: "é«˜åº¦è¨ˆ", definition: "æ¸¬é‡æµ·æ‹”é«˜åº¦çš„å„€å™¨", hint: "é¡¯ç¤ºä½ åœ¨å¤šé«˜çš„è£ç½®" },
      { id: 42, term: "æŒ‡åŒ—é‡", definition: "æŒ‡ç¤ºåŒ—æ–¹æ–¹å‘çš„å°èˆªå·¥å…·", hint: "æ‰¾æ–¹å‘çš„åŸºæœ¬å·¥å…·" },
      { id: 43, term: "GPS", definition: "å…¨çƒè¡›æ˜Ÿå®šä½ç³»çµ±", hint: "ç”¨è¡›æ˜Ÿå®šä½çš„é›»å­è¨­å‚™" },
      { id: 44, term: "é›¢ç·šåœ°åœ–", definition: "ä¸éœ€ç¶²è·¯å³å¯ä½¿ç”¨çš„é›»å­åœ°åœ–", hint: "æ²’è¨Šè™Ÿä¹Ÿèƒ½çœ‹çš„åœ°åœ–" },
      { id: 45, term: "ç´®ç‡Ÿ", definition: "æ­è¨­å¸³ç¯·æº–å‚™éå¤œ", hint: "åœ¨é‡å¤–æ­å¸³ç¯·ç¡è¦º" },
      { id: 46, term: "ç‚Šç…®", definition: "åœ¨å±±ä¸Šæº–å‚™é£Ÿç‰©çš„è¡Œç‚º", hint: "åœ¨ç‡Ÿåœ°ç…®é£¯" },
      { id: 47, term: "æ·¨å±±", definition: "æ¸…ç†å±±å€åƒåœ¾ç¶­è­·ç’°å¢ƒ", hint: "æŠŠå±±ä¸Šçš„åƒåœ¾å¸¶ä¸‹å±±" },
      { id: 48, term: "ç„¡ç—•å±±æ—", definition: "ä¸ç•™ä¸‹ä»»ä½•ç—•è·¡çš„ç™»å±±ç†å¿µ", hint: "ä¿è­·ç’°å¢ƒçš„ç™»å±±æ…‹åº¦" },
      { id: 49, term: "å±±å‹", definition: "å…±åŒç™»å±±çš„å¤¥ä¼´", hint: "ä¸€èµ·çˆ¬å±±çš„æœ‹å‹" },
      { id: 50, term: "ç™»é ‚ç…§", definition: "åœ¨å±±é ‚æ‹æ”çš„ç´€å¿µç…§ç‰‡", hint: "æ”»é ‚æˆåŠŸçš„è­‰æ˜ç…§" }
    ];

    let vocabularyData = [];

    // Default Config
    const defaultConfig = {
      game_title: "â›°ï¸ ç™»å±±çŸ¥è­˜é…å°æŒ‘æˆ°",
      hint_button_text: "æç¤º",
      restart_button_text: "é‡æ–°é–‹å§‹",
      background_color: "#312e81",
      card_color: "#ffffff",
      text_color: "#1f2937",
      accent_color: "#8b5cf6",
      success_color: "#10b981",
      font_family: "Nunito"
    };

    // Game State
    let gameState = {
      score: 0,
      matchedPairs: 0,
      streak: 0,
      hintsRemaining: 3,
      selectedTerm: null,
      selectedDefinition: null,
      matchedIds: [],
      shuffledTerms: [],
      shuffledDefinitions: [],
      isDragging: false,
      dragStartId: null,
      dragStartType: null,
      currentLine: null
    };

    // Shuffle array
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Select random questions from pool
    function selectRandomQuestions(count = 6) {
      const shuffled = shuffleArray(allVocabularyData);
      return shuffled.slice(0, count);
    }

    // Create confetti
    function createConfetti() {
      const colors = ['#f43f5e', '#8b5cf6', '#3b82f6', '#10b981', '#f59e0b', '#ec4899'];
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 2 + 's';
        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 3000);
      }
    }

    // Create mini celebration
    function miniCelebration(element) {
      const emojis = ['â­', 'âœ¨', 'ğŸ’«', 'ğŸŒŸ'];
      for (let i = 0; i < 5; i++) {
        const particle = document.createElement('div');
        particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        particle.className = 'fixed text-2xl pointer-events-none';
        particle.style.zIndex = '1000';
        const rect = element.getBoundingClientRect();
        particle.style.left = rect.left + rect.width / 2 + 'px';
        particle.style.top = rect.top + rect.height / 2 + 'px';
        particle.style.transition = 'all 1s ease-out';
        document.body.appendChild(particle);
        
        setTimeout(() => {
          particle.style.transform = `translate(${(Math.random() - 0.5) * 100}px, ${-100 - Math.random() * 50}px)`;
          particle.style.opacity = '0';
        }, 50);
        
        setTimeout(() => particle.remove(), 1000);
      }
    }

    // Draw connection line
    function drawConnection(termId, defId, color = '#8b5cf6') {
      const svg = document.getElementById('connection-svg');
      const container = document.getElementById('game-container');
      const termCard = document.querySelector(`[data-term-id="${termId}"]`);
      const defCard = document.querySelector(`[data-def-id="${defId}"]`);
      
      if (!termCard || !defCard) return;
      
      const containerRect = container.getBoundingClientRect();
      const termRect = termCard.getBoundingClientRect();
      const defRect = defCard.getBoundingClientRect();
      
      const x1 = termRect.right - containerRect.left;
      const y1 = termRect.top + termRect.height / 2 - containerRect.top;
      const x2 = defRect.left - containerRect.left;
      const y2 = defRect.top + defRect.height / 2 - containerRect.top;
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '3');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('data-connection', `${termId}-${defId}`);
      line.style.opacity = '0.7';
      
      svg.appendChild(line);
    }



    // Initialize game
    function initGame() {
      // Select 6 random questions from the pool of 50
      vocabularyData = selectRandomQuestions(6);
      
      gameState = {
        score: 0,
        matchedPairs: 0,
        streak: 0,
        hintsRemaining: 3,
        selectedTerm: null,
        selectedDefinition: null,
        matchedIds: [],
        shuffledTerms: shuffleArray(vocabularyData),
        shuffledDefinitions: shuffleArray(vocabularyData),
        isDragging: false,
        dragStartId: null,
        dragStartType: null,
        currentLine: null
      };
      
      document.getElementById('connection-svg').innerHTML = '';
      updateUI();
      renderCards();
    }
    
    // Get card center position
    function getCardCenter(element) {
      const rect = element.getBoundingClientRect();
      const container = document.getElementById('game-container');
      const containerRect = container.getBoundingClientRect();
      
      return {
        x: rect.left + rect.width / 2 - containerRect.left,
        y: rect.top + rect.height / 2 - containerRect.top
      };
    }
    
    // Draw temporary line during drag
    function drawTempLine(x1, y1, x2, y2) {
      const svg = document.getElementById('connection-svg');
      
      // Remove existing temp line
      const existingTemp = svg.querySelector('line[data-temp="true"]');
      if (existingTemp) {
        existingTemp.remove();
      }
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', '#a78bfa');
      line.setAttribute('stroke-width', '3');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('stroke-dasharray', '5,5');
      line.setAttribute('data-temp', 'true');
      line.style.opacity = '0.7';
      
      svg.appendChild(line);
    }
    
    // Remove temporary line
    function removeTempLine() {
      const svg = document.getElementById('connection-svg');
      const tempLine = svg.querySelector('line[data-temp="true"]');
      if (tempLine) {
        tempLine.remove();
      }
    }
    
    // Start drag from card
    function startDrag(id, type, event) {
      if (gameState.matchedIds.includes(id)) return;
      
      event.preventDefault();
      gameState.isDragging = true;
      gameState.dragStartId = id;
      gameState.dragStartType = type;
      
      const card = type === 'term' 
        ? document.querySelector(`[data-term-id="${id}"]`)
        : document.querySelector(`[data-def-id="${id}"]`);
      
      card.classList.add('ring-4', 'ring-purple-400', 'scale-105');
      
      const center = getCardCenter(card);
      gameState.currentLine = { x: center.x, y: center.y };
    }
    
    // Continue drag
    function onDrag(event) {
      if (!gameState.isDragging) return;
      
      event.preventDefault();
      const container = document.getElementById('game-container');
      const containerRect = container.getBoundingClientRect();
      
      let clientX, clientY;
      if (event.type === 'touchmove') {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      } else {
        clientX = event.clientX;
        clientY = event.clientY;
      }
      
      const x2 = clientX - containerRect.left;
      const y2 = clientY - containerRect.top;
      
      drawTempLine(gameState.currentLine.x, gameState.currentLine.y, x2, y2);
    }
    
    // End drag on card
    function endDragOnCard(id, type, event) {
      if (!gameState.isDragging) return;
      if (gameState.matchedIds.includes(id)) return;
      
      event.preventDefault();
      
      // Check if we're connecting term to definition or vice versa
      const isValidConnection = 
        (gameState.dragStartType === 'term' && type === 'definition') ||
        (gameState.dragStartType === 'definition' && type === 'term');
      
      if (isValidConnection) {
        const termId = gameState.dragStartType === 'term' ? gameState.dragStartId : id;
        const defId = gameState.dragStartType === 'definition' ? gameState.dragStartId : id;
        
        checkConnection(termId, defId);
      }
      
      endDrag();
    }
    
    // End drag
    function endDrag() {
      if (!gameState.isDragging) return;
      
      gameState.isDragging = false;
      removeTempLine();
      
      // Remove highlighting
      document.querySelectorAll('.term-card, .def-card').forEach(card => {
        card.classList.remove('ring-4', 'ring-purple-400', 'scale-105');
      });
      
      gameState.dragStartId = null;
      gameState.dragStartType = null;
      gameState.currentLine = null;
    }
    
    // Check connection
    function checkConnection(termId, defId) {
      const termCard = document.querySelector(`[data-term-id="${termId}"]`);
      const defCard = document.querySelector(`[data-def-id="${defId}"]`);
      
      if (termId === defId) {
        // Correct match!
        gameState.matchedIds.push(termId);
        gameState.matchedPairs++;
        gameState.streak++;
        gameState.score += 100 + (gameState.streak * 10);
        
        // Draw permanent connection
        drawConnection(termId, defId, '#10b981');
        const svg = document.getElementById('connection-svg');
        const line = svg.querySelector(`line[data-connection="${termId}-${defId}"]`);
        if (line) {
          line.setAttribute('data-matched', 'true');
        }
        
        termCard.classList.add('card-matched');
        defCard.classList.add('card-matched');
        
        miniCelebration(termCard);
        miniCelebration(defCard);
        
        setTimeout(() => {
          renderCards();
          
          if (gameState.matchedPairs === 6) {
            showCompletionModal();
          }
        }, 600);
        
      } else {
        // Wrong match
        gameState.streak = 0;
        
        termCard.classList.add('card-wrong', 'ring-4', 'ring-red-500');
        defCard.classList.add('card-wrong', 'ring-4', 'ring-red-500');
        
        setTimeout(() => {
          termCard.classList.remove('card-wrong', 'ring-4', 'ring-red-500');
          defCard.classList.remove('card-wrong', 'ring-4', 'ring-red-500');
        }, 500);
      }
      
      updateUI();
    }

    // Update UI elements
    function updateUI() {
      document.getElementById('score').textContent = gameState.score;
      document.getElementById('progress').textContent = `${gameState.matchedPairs}/6`;
      document.getElementById('streak').textContent = gameState.streak;
      document.getElementById('hints-remaining').textContent = gameState.hintsRemaining;
      
      const hintBtn = document.getElementById('hint-btn');
      if (gameState.hintsRemaining <= 0) {
        hintBtn.classList.add('opacity-50', 'cursor-not-allowed');
        hintBtn.disabled = true;
      } else {
        hintBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        hintBtn.disabled = false;
      }
    }

    // Render cards
    function renderCards() {
      const termsColumn = document.getElementById('terms-column');
      const defsColumn = document.getElementById('definitions-column');
      
      termsColumn.innerHTML = '';
      defsColumn.innerHTML = '';
      
      gameState.shuffledTerms.forEach((item, index) => {
        const isMatched = gameState.matchedIds.includes(item.id);
        const card = document.createElement('div');
        card.className = `term-card p-3 md:p-4 rounded-xl transform transition-all duration-300 float-in ${isMatched ? 'bg-emerald-500 cursor-default' : 'bg-white hover:shadow-xl cursor-grab active:cursor-grabbing'}`;
        card.style.animationDelay = `${index * 0.1}s`;
        card.setAttribute('data-term-id', item.id);
        
        if (isMatched) {
          card.innerHTML = `
            <div class="flex items-center gap-2">
              <span class="text-xl md:text-2xl">âœ…</span>
              <span class="font-bold text-white text-sm md:text-lg">${item.term}</span>
            </div>
          `;
        } else {
          card.innerHTML = `
            <div class="flex items-center gap-2">
              <span class="text-xl md:text-2xl">â›°ï¸</span>
              <span class="font-bold text-gray-800 text-sm md:text-lg">${item.term}</span>
            </div>
          `;
          
          // Mouse events
          card.addEventListener('mousedown', (e) => startDrag(item.id, 'term', e));
          card.addEventListener('mouseup', (e) => endDragOnCard(item.id, 'term', e));
          card.addEventListener('mouseenter', (e) => {
            if (gameState.isDragging && gameState.dragStartType === 'definition') {
              card.classList.add('ring-2', 'ring-green-400');
            }
          });
          card.addEventListener('mouseleave', (e) => {
            card.classList.remove('ring-2', 'ring-green-400');
          });
          
          // Touch events
          card.addEventListener('touchstart', (e) => startDrag(item.id, 'term', e));
          card.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element) {
              const defCard = element.closest('[data-def-id]');
              if (defCard) {
                const defId = parseInt(defCard.getAttribute('data-def-id'));
                endDragOnCard(defId, 'definition', e);
                return;
              }
            }
            endDrag();
          });
        }
        
        termsColumn.appendChild(card);
      });
      
      gameState.shuffledDefinitions.forEach((item, index) => {
        const isMatched = gameState.matchedIds.includes(item.id);
        const card = document.createElement('div');
        card.className = `def-card p-3 md:p-4 rounded-xl transform transition-all duration-300 float-in ${isMatched ? 'bg-emerald-500 cursor-default' : 'bg-white/90 hover:shadow-xl cursor-grab active:cursor-grabbing'}`;
        card.style.animationDelay = `${index * 0.1 + 0.3}s`;
        card.setAttribute('data-def-id', item.id);
        
        if (isMatched) {
          card.innerHTML = `
            <div class="flex items-center gap-2">
              <span class="text-xl md:text-2xl">âœ…</span>
              <span class="text-white text-xs md:text-sm">${item.definition}</span>
            </div>
          `;
        } else {
          card.innerHTML = `
            <span class="text-gray-700 text-xs md:text-sm">${item.definition}</span>
          `;
          
          // Mouse events
          card.addEventListener('mousedown', (e) => startDrag(item.id, 'definition', e));
          card.addEventListener('mouseup', (e) => endDragOnCard(item.id, 'definition', e));
          card.addEventListener('mouseenter', (e) => {
            if (gameState.isDragging && gameState.dragStartType === 'term') {
              card.classList.add('ring-2', 'ring-green-400');
            }
          });
          card.addEventListener('mouseleave', (e) => {
            card.classList.remove('ring-2', 'ring-green-400');
          });
          
          // Touch events
          card.addEventListener('touchstart', (e) => startDrag(item.id, 'definition', e));
          card.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element) {
              const termCard = element.closest('[data-term-id]');
              if (termCard) {
                const termId = parseInt(termCard.getAttribute('data-term-id'));
                endDragOnCard(termId, 'term', e);
                return;
              }
            }
            endDrag();
          });
        }
        
        defsColumn.appendChild(card);
      });
    }



    // Show hint
    function showHint() {
      if (gameState.hintsRemaining <= 0) return;
      
      const unmatched = vocabularyData.filter(item => !gameState.matchedIds.includes(item.id));
      if (unmatched.length === 0) return;
      
      const randomItem = unmatched[Math.floor(Math.random() * unmatched.length)];
      
      gameState.hintsRemaining--;
      updateUI();
      
      // Show hint text
      const hintMessage = document.getElementById('hint-message');
      const hintText = document.getElementById('hint-text');
      hintText.textContent = `ğŸ’¡ ã€Œ${randomItem.term}ã€çš„æç¤ºï¼š${randomItem.hint}`;
      hintMessage.classList.remove('hidden');
      
      // Highlight the term
      const termCard = document.querySelector(`[data-term-id="${randomItem.id}"]`);
      if (termCard && !gameState.matchedIds.includes(randomItem.id)) {
        termCard.classList.add('card-hint');
        setTimeout(() => {
          termCard.classList.remove('card-hint');
        }, 3000);
      }
    }

    // Hide hint
    function hideHint() {
      document.getElementById('hint-message').classList.add('hidden');
      document.querySelectorAll('.card-hint').forEach(card => {
        card.classList.remove('card-hint');
      });
    }

    // Show completion modal
    function showCompletionModal() {
      createConfetti();
      document.getElementById('final-score').textContent = gameState.score;
      document.getElementById('completion-modal').classList.remove('hidden');
    }

    // Element SDK Integration
    async function onConfigChange(config) {
      const font = config.font_family || defaultConfig.font_family;
      document.body.style.fontFamily = `${font}, sans-serif`;
      
      document.getElementById('game-title').textContent = config.game_title || defaultConfig.game_title;
      document.getElementById('hint-btn-text').textContent = config.hint_button_text || defaultConfig.hint_button_text;
      document.getElementById('restart-btn-text').textContent = config.restart_button_text || defaultConfig.restart_button_text;
      
      // Apply colors
      const bgColor = config.background_color || defaultConfig.background_color;
      const cardColor = config.card_color || defaultConfig.card_color;
      const textColor = config.text_color || defaultConfig.text_color;
      const accentColor = config.accent_color || defaultConfig.accent_color;
      const successColor = config.success_color || defaultConfig.success_color;
      
      document.getElementById('app').style.background = `linear-gradient(135deg, ${bgColor} 0%, ${adjustColor(bgColor, 20)} 50%, ${adjustColor(bgColor, 40)} 100%)`;
      
      document.querySelectorAll('.term-card:not(.bg-emerald-500), .def-card:not(.bg-emerald-500)').forEach(card => {
        card.style.backgroundColor = cardColor;
        card.style.color = textColor;
      });
    }
    
    function adjustColor(hex, percent) {
      const num = parseInt(hex.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, (num >> 16) + amt);
      const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
      const B = Math.min(255, (num & 0x0000FF) + amt);
      return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
    }

    function mapToCapabilities(config) {
      return {
        recolorables: [
          {
            get: () => config.background_color || defaultConfig.background_color,
            set: (value) => { config.background_color = value; window.elementSdk.setConfig({ background_color: value }); }
          },
          {
            get: () => config.card_color || defaultConfig.card_color,
            set: (value) => { config.card_color = value; window.elementSdk.setConfig({ card_color: value }); }
          },
          {
            get: () => config.text_color || defaultConfig.text_color,
            set: (value) => { config.text_color = value; window.elementSdk.setConfig({ text_color: value }); }
          },
          {
            get: () => config.accent_color || defaultConfig.accent_color,
            set: (value) => { config.accent_color = value; window.elementSdk.setConfig({ accent_color: value }); }
          },
          {
            get: () => config.success_color || defaultConfig.success_color,
            set: (value) => { config.success_color = value; window.elementSdk.setConfig({ success_color: value }); }
          }
        ],
        borderables: [],
        fontEditable: {
          get: () => config.font_family || defaultConfig.font_family,
          set: (value) => { config.font_family = value; window.elementSdk.setConfig({ font_family: value }); }
        },
        fontSizeable: undefined
      };
    }

    function mapToEditPanelValues(config) {
      return new Map([
        ["game_title", config.game_title || defaultConfig.game_title],
        ["hint_button_text", config.hint_button_text || defaultConfig.hint_button_text],
        ["restart_button_text", config.restart_button_text || defaultConfig.restart_button_text]
      ]);
    }

    // Initialize SDK
    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }

    // Event Listeners
    document.getElementById('hint-btn').addEventListener('click', showHint);
    document.getElementById('restart-btn').addEventListener('click', initGame);
    document.getElementById('play-again-btn').addEventListener('click', () => {
      document.getElementById('completion-modal').classList.add('hidden');
      initGame();
    });
    
    // Global drag listeners
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchmove', onDrag, { passive: false });
    document.addEventListener('touchend', endDrag);

    // Start game
    initGame();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9bea066876b94a88',t:'MTc2ODUyODg4OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
